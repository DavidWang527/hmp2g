<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - layers</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="/files/main.css">
	<style>
		body {
			background-color: #f0f0f0;
			color: #444;
		}

		a {
			color: #08f;
		}
	</style>
</head>

<body>

	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl layers
	</div>
	<script src='/build/three.js'></script>
	<script src='/examples/jsm/threex.dynamictexture.js'></script>
	<script type="module">
		// import * as THREE from '/build/three.module.js';
		import Stats from '/examples/jsm/libs/stats.module.js';
		import { GUI } from '/examples/jsm/libs/dat.gui.module.js';
		import { FlyControls } from '/examples/jsm/controls/FlyControls.js';
		import { OrbitControls } from '/examples/jsm/controls/OrbitControls.js';
		// import { core_update } from '/examples/abc.js';

		// 由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的
		// 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量
		let container, stats;
		var camera, renderer;
		var controls;
		var scene;
		let theta = 0;
		// ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：
		const radius = 100;
		const clock = new THREE.Clock();
		// 历史轨迹
		var core_L = [];
		var core_Obj = [];
		// global vars
		var play_fps = 10;
		var dt_since = 0;
		var dt_threshold = 1 / play_fps;
		var play_pointer = 0;
		var buf_str = '';
		var init_cam = false;
		var DEBUG = false;
		// GUI
		var req_interval;
		var bar_folder;
		let panelSettings = {
				'play fps':play_fps,
				'play pointer':0,
				'data req interval': 1.0
		};
		// color dictionary 
		var color_dic = {
			k:0x000000,
			r:0xff0000, 
			g:0x00ff00, 
			b:0x0000ff, 
		};
		var color_layer = {
			k:0,
			r:1, 
			g:2, 
			b:3, 
		};
		init();
		animate();



		function core_update(buf) {
			let tmp = buf.split('>>v2d_show()\n');
			core_L = core_L.concat(tmp);
			if (core_L.length>1e6){
				core_L.splice(0, tmp.length);
				play_pointer = play_pointer - tmp.length;
				if (play_pointer<0){
					play_pointer=0;
				}
			}
			bar_folder.__controllers[0].max(core_L.length)
		}
		if (DEBUG){
			setTimeout(function () {
				// Get today's date and time
				const request = new XMLHttpRequest();
				request.open('POST', `/up`);
				request.onload = () => {
					core_update(request.responseText)
				};
				request.send();
			}, 2000);
		}
		else{
			var coreReadFunc = function () {
				// Get today's date and time
				const request = new XMLHttpRequest();
				request.open('POST', `/up`);
				request.onload = () => {
					core_update(request.responseText)
				};
				request.send();
			}
			req_interval = setInterval(coreReadFunc, 1000);
		}

		function addCoreObj(name, color_str, geometry, x, y, z, size){
			const object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: color_dic[color_str] }));
			object.name = name;
			object.color_str = color_str;
			object.position.x = x; // -400 ~ 400
			object.position.y = y; // -400 ~ 400
			object.position.z = z; // -400 ~ 400
			object.next_pos = Object.create(object.position);
			object.prev_pos = Object.create(object.position);
			object.rotation.x = 0;  //Math.random() * 2 * Math.PI; // 0 ~ 360
			object.rotation.y = 0;  //Math.random() * 2 * Math.PI; // 0 ~ 360
			object.rotation.z = 0;  //Math.random() * 2 * Math.PI; // 0 ~ 360
			object.generalSize = size
			object.scale.x = 1; //Math.random() + 0.5;
			object.scale.y = 1; //Math.random() + 0.5;
			object.scale.z = 1; //Math.random() + 0.5;
			object.label_marking = 'abc'
			object.layers.set(color_layer[color_str]);

			if (!init_cam){
				console.log('first')
				init_cam=true;
				controls.target.set(object.position.x, -size, object.position.z); // 旋转的焦点在哪0,0,0即原点
				camera.position.set(object.position.x, size*100, object.position.z)
			}

			makeClearText(object, object.label_marking, 10)
			scene.add(object);
			core_Obj.push(object)
		}

		function makeClearText(object, text, HWRatio=10){
			let textTextureHeight = 512
			let textTextureWidth = 512*HWRatio
			object.dynamicTexture  = new THREEx.DynamicTexture(textTextureWidth, textTextureHeight)
			let px = 256
			object.dynamicTexture.context.font	= `bolder ${px}px Verdana`
			object.dynamicTexture.drawText(text, 0, +80, 'black')	// text, x ,y, fillStyle（font color）, contextFont
			const materialB = new THREE.SpriteMaterial({ map:  object.dynamicTexture.texture, depthWrite: false });
			const sprite = new THREE.Sprite(materialB);

			sprite.scale.x = 17* object.generalSize
			sprite.scale.y = 17* object.generalSize/HWRatio
			sprite.scale.z = 17* object.generalSize
			sprite.position.set(object.generalSize, object.generalSize, -object.generalSize);
			object.add(sprite)
		}

		function removeEntity(object) {
			var selectedObject = scene.getObjectByName(object.name);
			scene.remove(selectedObject);
		}

		function changeCoreObjColor(object, color_str){
			const colorjs = color_dic[color_str];
			object.material.color.set(colorjs)
			object.layers.set(color_layer[color_str])
			object.color_str = color_str;
		}


		// name, xpos, ypos, dir=0, **kargs
		function parse_update(buf_str) {
			let each_line = buf_str.split('\n')
			for (let i = 0; i < each_line.length; i++) {
				var str = each_line[i]
				if (str.search("v2dx") != -1) {
					// ">>v2dx(x, y, dir, xxx)"
					// each_line[i].replace('>>v2dx(')
					const pattern = />>v2dx\('(.*)',([^,]*),([^,]*),(.*)\)/
					let match_res = str.match(pattern)
					let name = match_res[1]
					// z --> y, y --- z
					let pos_x = parseFloat(match_res[2])
					let pos_y = 0
					let pos_z = parseFloat(match_res[3])
					// pattern.test(str)
					let name_split = name.split('|')
					let type = name_split[0]
					let id = parseInt(name_split[1])
					let color_str = name_split[2]
					let size = name_split[3]
					size = name_split[3]
					let label_marking = `id ${name_split[1]}`
					// find hp 
					const hp_pattern = /health=([^,)]*)/
					let hp_match_res = str.match(hp_pattern)
					if (!(hp_match_res === null)){
						let hp = parseFloat(hp_match_res[1])
						if (Number(hp) === hp && hp % 1 === 0){
							// is an int
							hp = Number(hp);
						}
						else{
							hp = hp.toFixed(2);
						}
					 	label_marking = `HP ${hp}`
					}
					
					// 已经创建了对象
					if (id < core_Obj.length) {
						let object = core_Obj[id]
						object.prev_pos = Object.assign({}, object.next_pos);
						object.next_pos.x = pos_x; // -400 ~ 400
						object.next_pos.y = pos_y; // -400 ~ 400
						object.next_pos.z = pos_z; // -400 ~ 400
						if (color_str != object.color_str){
							changeCoreObjColor(object, color_str)
						}
						if (label_marking != object.label_marking){
							object.label_marking = label_marking
							object.dynamicTexture.clear().drawText(label_marking, 0, -30, 'black')
						}
					}
					else {
						// create obj
						const geometry2 = new THREE.BoxGeometry(size, size, size);
						addCoreObj(name, color_str, geometry2, pos_x, pos_y, pos_z, size)
					}
				}
			}
		}


		function move_to_future(percent) {
			for (let i = 0; i < core_Obj.length; i++) {
				let object = core_Obj[i]
				object.position.x = object.prev_pos.x * (1 - percent) + object.next_pos.x * percent
				object.position.y = object.prev_pos.y * (1 - percent) + object.next_pos.y * percent
				object.position.z = object.prev_pos.z * (1 - percent) + object.next_pos.z * percent
			}
		}


		function set_next_play_frame() {
			if (core_L.length == 0) { return; }
			if (play_pointer >= core_L.length) { play_pointer = 0; }
			buf_str = core_L[play_pointer]
			parse_update(buf_str)
			play_pointer = play_pointer + 1
			panelSettings['play pointer'] = play_pointer;
		}



		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		// 没变化

		function animate() {
			requestAnimationFrame(animate);

			render();
			stats.update();
		}

		function render() {
			const delta = clock.getDelta();
			dt_since = dt_since + delta;
			if (dt_since > dt_threshold) {
				dt_since = 0;
				set_next_play_frame();
				move_to_future(0);
			}
			else {
				let percent = Math.min(dt_since / dt_threshold, 1.0);
				// console.log(percent)
				move_to_future(percent);
			}
			// controls.update( delta );
			renderer.render(scene, camera);
			// console.log(camera)

		}


		function init() {
			container = document.createElement('div');
			document.body.appendChild(container);
			// 透视相机 
			// Fov – 相机的视锥体的垂直视野角
			// Aspect – 相机视锥体的长宽比
			// Near – 相机视锥体的近平面
			// Far – 相机视锥体的远平面
			camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.001, 10000);
			// camera.up.set(0,0,1);
			// 一个 0 - 31 的整数
			// Layers 对象为 Object3D 分配 1个到 32 个图层。32个图层从 0 到 31 编号标记。
			// 在内部实现上，每个图层对象被存储为一个 bit mask，
			// 默认的，所有 Object3D 对象都存储在第 0 个图层上。
			for (let i = 0; i < Object.keys(color_layer).length; i++) {
				camera.layers.enable(i); // 启动0图层
			}
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xa0a0a0);
			// ground
			// const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), 
			// new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false })
			// );
			// mesh.rotation.x = - Math.PI / 2;
			// mesh.receiveShadow = true;
			// scene.add(mesh);

			const grid = new THREE.GridHelper( 500, 500, 0xffffff, 0x555555 );
			grid.position.y = 0
			scene.add(grid);
			const light = new THREE.PointLight(0xffffff, 1);
			for (let i = 0; i < Object.keys(color_layer).length; i++) {
				light.layers.enable(i); // 启动0图层
			}
			scene.add(camera);
			camera.add(light);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			stats = new Stats();
			container.appendChild(stats.dom);

			controls = new OrbitControls(camera, renderer.domElement);
			// controls.object.up = new THREE.Vector3( 1, 0, 0 )
			controls.target.set(0, 0, 0); // 旋转的焦点在哪0,0,0即原点
			camera.position.set(0, 50, 0)
			controls.update();
			controls.autoRotate = false;

			
			const panel = new GUI( { width: 310 } );
			const folder3 = panel.addFolder( 'General' );
			// FPS adjust
			folder3.add(panelSettings, 'play fps', 0, 144, 1).onChange(
				function change_fps(fps) {
					// mixer.timeScale = speed;
					// console.log(fps)
					play_fps = fps;
					dt_since = 0;
					// if (fps==0){

					// }
					dt_threshold = 1 / play_fps;
				});
			folder3.add(panelSettings, 'data req interval', 1, 100, 1).onChange(
				function (interval) {
					clearInterval(req_interval);
					req_interval = setInterval(coreReadFunc, interval*1000);
			});
			folder3.open();

			bar_folder = panel.addFolder('Play Pointer');
			bar_folder.add(panelSettings, 'play pointer', 0, 10000, 1).listen().onChange(
				function (p) {
					play_pointer = p;
			});
			bar_folder.open();

			window.addEventListener('resize', onWindowResize);
		}

	</script>

</body>

</html>